---
layout:     post
title:      Deadlock в RSpec
date:       2019-12-25 00:09
categories: Rails
---


Недавно мне на глаза попался  [_pull
request_](https://github.com/rspec/rspec-core/pull/2669) с исправлением
бага в RSpec. Баг был связан с _deadlock_'ом между процессами RSpec,
который приводил, очевидно, к зависанию. Я не смог пройти мимо и не
покопаться в деталях - не каждый же день встречаешь _deadlock_ в
Ruby-коде.

В RSpec есть такая опция командной строки `--bisect`
([документация](https://relishapp.com/rspec/rspec-core/docs/command-line/bisect)),
которая помогает бороться со случайно падающими тестами. Если падение
теста зависит от порядка запуска, т.е. от того какие тесты были запущены
перед ним, то такую минимальную последовательность тестов несложно
определить используя `--bisect`. С этой опцией RSpec многократно
перезапускает подмножество тесты раз за разом уменьшая их количество
вдвое. В конце остается минимальная последовательность тестов, которые
приводят к падению. Таким образом, RSpec должен несколько раз запустить
тесты изолированно друг от друга. В идеале их надо запускать в
независимых процессах.

Так вот, иногда RSpec запущенный с опцией `--bisect` может намертво
зависнуть. Впервые это
[зарепортили](https://github.com/rspec/rspec-core/issues/2637)
_maintainer_'ы Puppet'а. Вдобавок они еще и разобрались в причина
зависания:

> Meanwhile the main process is hanging in waitpid at
>
> Process.waitpid(pid)
>
> A common reason why this might not show up in testing is if the result
> report in the tests is smaller than the underlying OS's buffer size. In
> that case the runner process exits after writing to the buffer and the
> parent continues happily reading from the buffer. In my case the
> testsuite results are ~93kB and the processes deadlock.

Если вам лень читать сам _issue_ или описание слишком лаконично и не
проливает свет на происходящее, тогда продолжим.


### Как работает `--bisect`

RSpec может запускать тесты двумя способами - запуская *shell*-команду
(что приводит к системным вызовам `fork` + `exec` или их аналогам) или
просто делая _fork_ своего процесса. В обоих случаях создается новый
дочерний процесс. В первом варианте результат выполнения тестов пишется
дочерним процессом в _stdout_, который доступен родителю. Во втором
варианте для передачи данных между процессами используется системный
неименованный [_pipe_](https://linux.die.net/man/7/pipe). Проблема
возникла именно с реализацией через _fork_.

Для чтения и записи в _pipe_ RSpec использует блокирующие операции -
дочерний процесс записывает в _pipe_ данные, а главный процесс ожидает
завершения дочернего и далее читает данные из _pipe_'а. Итак, у нас есть
три блокирующие операции - блокирующее чтение, блокирующая запись и
ожидание завершения дочернего процесса. Давайте остановимся на этом
подробнее.

Блокирующее чтение означает, что если мы хотим прочитать n байт, но
сейчас в системном буфере доступно меньше данных, операция чтения будет
ожидать пока не придут остальные данные.

Блокирующая запись означает, что если мы хотим записать n байт, а в
системном буфере не хватает свободного места (он же конечный и
фиксированной длины), то операция записи будет ожидать, пока кто-то не
прочитает данные из буфера и не освободится нужное место.

Чтобы дождаться завершения дочернего процесса родительский делает
системный вызов `waitpid`. Когда процесс завершается, он переходит в
состояние "зомби" - его ресурсы уже освобождены, но родительский процесс
еще не узнал о завершении процесса. Родительский процесс обязан получить
статус завершения дочернего процесса (успех или ошибку) вызовом
`waitpid` (или аналогичным). После этого дочерний процесс окончательно
удаляется из системы.

Давайте проиллюстрируем это *sequence*-диаграммой:

<img src="/assets/images/2019-12-25-deadlock-in-rspec/success.svg"/>

_Parent process_ создает новый дочерний процесс делая _fork_ и ожидает
его завершение. В новом процессе запускаются тесты и результат
записывается в _Pipe_. Дочерний процесс завершается и операционная
система (_Kernel_) возвращает статус завершения _Parent process_'у как
результат вызова `waitpid`. Далее _Parent process_ читает данные из
_Pipe_ и продолжает операцию _bisect_.


### Разбираем баг

Проблему смогли стабильно
[воспроизвести](https://github.com/benoittgt/rspec_repro_bisect_deadlock)
вот таким тестом:

```ruby
RSpec.describe "a bunch of nothing" do
  (0...3000).each do |t|
    it { expect(t).to eq t }
  end
end
```

Теперь команда `rspec --bisect=verbose` будет стабильно зависать.

Упрощенно реализация в RSpec запуска тестов в дочернем процессе и
передача результатов выглядит так:

```ruby
@read_io, @write_io = IO.pipe

# write into pipe some data
def run_specs
  packet = '*' * 1000
  @write_io.write("#{packet.bytesize}\n#{packet}")
end

# create a child process
pid = fork { run_specs }

# wait for its terminating
Process.waitpid(pid)

# read result
packet_size = Integer(@read_io.gets)
packet = @read_io.read(packet_size)

puts "packet size: #{packet.size}"
```

Здесь мы создаем _pipe_ и получаем два `IO` объекта для записи в _pipe_
(`@write_io`) и для чтения из него (`@read_io`). Далее вызовом метода
`fork` создается новый дочерний процесс, в котором выполняется
переданный блок - `{ run_specs }`. Дочерний процесс наследует все
файловые дескрипторы родительского, в том числе и дескрипторы для
_pipe_'а. Метод `run_specs` выполняется в дочернем процессе и просто
записывает в _pipe_ данные (1000 символов, т.е. байт). Родительский
процесс после создания дочернего начинает ждать его завершения делая
вызов `waitpid`. Затем он читает данные из _pipe_'а.

Если вы запустите этот код, все успешно отработает и в консоль выведется
сообщение "packet size: 1000".

Но если вы увеличите 1000 до 66000, т.е. дочерний процесс будет
записывать не 1000 байт, а 66000, то RSpec зависнет.

Причина лежит на поверхности - размер буфера _pipe_'а ограничен. Если мы
хотим записать в _pipe_ больше данных, чем он может вместить, то
блокирующая операция чтения заблокируется и будет ждать, пока кто-то не
начнет читать из _pipe_'а и не освободить место, чтобы все-таки записать
в буфер все оставшиеся данные. Но никто не читает из буфера.
Родительский процесс будет читать, но только после завершения работы
дочернего. А дочерний не может завершиться, потому что не может
отправить до конца все данные в _pipe_. В данном случае длина
записываемых данных (66000) должен быть заведомо больше размера буфера
_pipe_'а.

Эту ситуации может проиллюстрировать следующая диаграмма:

<img src="/assets/images/2019-12-25-deadlock-in-rspec/deadlock.svg"/>

Оба процесса сделали блокирующие вызовы (запись в _pipe_ и ожидание
завершения дочернего процесса) и попали в _deadlock_.

Таким образом, если запуск тестов в дочернем процессе записывает в
_stdout_ данные размером меньше чем 64 Kb, то все работает. Если размер
данных превышают 64 Kb - получается _deadlock_ и RSpec зависает.


### Размер буфера pipe'а

Размер буфера никак не определяется ни стандартом POSIX ни документацией
операционных систем. Величина зависит от реализации и, более того она,
может быть не фиксированной.

Экспериментальным путем выясняются следующие числа (в байтах):

Darwin 13.4.0	|	65536
Linux 3.16.0	|	65536
Linux 4.4.59	|	65536
Solaris 10	|	20480
Solaris 11.3	|	25599

В тоже время на MacOS размер буфера по умолчанию составляет 16 Kb, но
операционная система может увеличить его до 64 Kb.

- <https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer>
- <https://github.com/afborchert/pipebuf>


### Заглянем в код RSpec

В реализации `--bisect` нас интересуют всего два файла
- `lib/rspec/core/bisect/fork_runner.rb` ([source](https://github.com/rspec/rspec-core/blob/v3.9.0/lib/rspec/core/bisect/fork_runner.rb)) и
- `lib/rspec/core/bisect/utilities.rb` ([source](https://github.com/rspec/rspec-core/blob/v3.9.0/lib/rspec/core/bisect/utilities.rb))

Здесь реализован запуск тестов через _fork_ (класс `ForkRunner`) и
обмен данными через _pipe_ (вспомогательный класс `Channel`).

Запуск тестов выполняется следующим образом:

```ruby
def dispatch_run(run_descriptor)
  @run_dispatcher.dispatch_specs(run_descriptor)
  @channel.receive.tap do |result|
    if result.is_a?(String)
      raise BisectFailedError.for_failed_spec_run(result)
    end
  end
end
```

Первым делом запускаются сами тесты:

```ruby
@run_dispatcher.dispatch_specs(run_descriptor)
```

а затем данные читаются из _pipe_'а используя `@channel`. Рассмотрим метод
`dispatch_specs` подробнее:

```ruby
def dispatch_specs(run_descriptor)
  pid = fork { run_specs(run_descriptor) }
  Process.waitpid(pid)
end
```

Здесь форкается дочерний процесс, а родительский дожидается его
завершения.


### PS

Баг пофиксили просто убрать вызов `Process.waitpid(pid)`. Теперь
родительский процесс сразу переходит к чтению данных избегая
_deadlock_'а.

С одной стороны проблема с _deadlock_'ом решена, но с другой дочерний
процесс остается в состоянии "зомби", так как никто не получает статус
его завершения системным вызовом `waitpid`. Это может привести к
исчерпанию лимита количества процессов в системе.


### Ссылки

- <https://github.com/rspec/rspec-core/issues/2637>
- <https://github.com/rspec/rspec-core/pull/2669>
- <https://relishapp.com/rspec/rspec-core/docs/command-line/bisect>
- <https://linux.die.net/man/3/waitpid>
- <https://linux.die.net/man/7/pipe>


[jekyll-gh]: https://github.com/mojombo/jekyll
[jekyll]:    http://jekyllrb.com
