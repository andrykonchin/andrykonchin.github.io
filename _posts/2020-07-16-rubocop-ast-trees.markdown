---
layout:     post
title:      Rubocop. Разбираем AST-деревья
date:       2020-07-16 22:37
categories: Ruby Rubocop
---

В самом-самом начале когда я только начинал заниматься Rubocop мне очень
не хватало информации и конкретных примеров. Сразу же возникли вопросы,
а какие узлы AST-дерева существуют, какие иерархии они могут
образовывать, какие могут быть дочерние узлы, как перемещаться по
дереву, в каком порядке вызываются _callback_'и и обрабатываются узлы
дерева, какой жизненный цикл у объекта-*cop*'а и как кешировать
промежуточные результаты... Документация не сильно помогала и
пришлось нырять самому.

Первая проблема была связана с узлами AST-дерева и его структурой -
какое AST-поддерево соответствует той или иной синтаксической
конструкции Ruby, какие дочерние узлы и в каком порядке идут у
конкретного типа узла. Поэтому в этом посте мы разберем несколько типов
узлом и примеров AST-дерева.

<img src="/assets/images/2020-07-09-rubocop-ast-trees/logo.jpg" />


Для AST-деревьев я буду использовать нотацию _gem_'a _parser_, который
под капотом и используется в Rubocop. AST-дерево представляет собой
[S-выражение](https://en.wikipedia.org/wiki/S-expression) и имеет
следующий вид:

```common-lisp
(parent-node child-node child-node ...)
```

где первым идет родительский узел, а затем его дочерние узлы.

Давайте рассмотрим несколько примеров и начнем с самого простого -
литералов.

### Литералы

Литерал базовых скалярных типов представляется двумя узлами - тип и
значение:

<img src="/assets/images/2020-07-09-rubocop-ast-trees/nodes-basic-int.svg" />

Давайте перечислим все базовые литералы:

```common-lisp
(int 1)
(float 2.0)
(rational (5/1))
(complex (0+1i))
(str "a")
(sym :b)
```

Такие константы как `nil`, `true` и `false` являются исключениями и
представлены только своим значением:

```common-lisp
(nil)
(true)
(false)
```

Литералы коллекций (массивов и хешей) имеют уже составную структуру.
Элементы массива становятся непосредственными дочерними узлами:

```ruby
[1, 2]
```

```common-lisp
(array
  (int 1)
  (int 2))
```

А в хеше каждая пара ключ-значение представлена дочерним узлом _pair_:

```ruby
{ a: 1 }
```

```common-lisp
(hash
  (pair
    (sym :a)
    (int 1)))
```


### Арифметическое выражение

Так как арифметические операции (например "+" и "*") в Ruby это методы
классов `Integer`/`Float`/итд, то в AST-дереве они представлены узлами
_send_ - "вызов метода":

Ruby выражение:

```ruby
1 + 2 * 3
```

S-выражение для дерева:

```common-lisp
(send
  (int 1) :+
  (send
    (int 2) :*
    (int 3)))
```

#### Выражение со скобками

Хорошо нам знакомые круглые скобки `()` в Ruby означают список
выражений. А итоговое значение этого списка - это значение последнего в
нем выражения. Поэтому в AST-дереве выражение в скобках представлено
узлом _begin_, который может содержать список выражений.  Рассмотрим
пример.

Ruby выражение:

```ruby
(1 + 2) * 3
```

S-выражение для дерева:

```common-lisp
(send
  (begin
    (send
      (int 1) :+
      (int 2))) :*
  (int 3))
```

### Вызов метода

Вызов метода представляется узлом _send_, в котором должны быть
следующие дочерние узлы:
- объект, на котором вызывается метод,
- имя метода
- и список аргументов.

Структура AST-дерева для вызова метода с одним аргументом:

<img src="/assets/images/2020-07-09-rubocop-ast-trees/nodes-basic-send.svg" />

Если объект, на котором вызывается метод, не литерал, константа или
локальная переменная, то это вызов метода, который тоже представляется
узлом _send_. Если у метода нет явного _receiver_'а - указывают _nil_.

Рассмотрим примеры.

#### Вызов метода без аргументов

Ruby выражение:

```ruby
post.title
```

S-выражение для дерева:

```common-lisp
(send
  (send nil :post) :title)
```

Само AST-дерево:

<img src="/assets/images/2020-07-09-rubocop-ast-trees/nodes-basic-send-wo-argument.svg" />

#### Вызов метода с аргументом

Ruby выражение:

```ruby
post.title(:html)
```

S-выражение для дерева:

```common-lisp
(send
  (send nil :post) :title
  (sym :html))
```

#### Вызов метода на литерале

Ruby выражение:

```ruby
5.div(2.0)
```

S-выражение для дерева:

```common-lisp
(send
  (int 5) :div
  (float 2.0))
```

AST-дерево:

<img src="/assets/images/2020-07-09-rubocop-ast-trees/nodes-basic-send-literal.svg" />

#### Вызов метода с блоком

Когда метод вызывается с блоком, это представляется в AST особым
образом. Родительским узлом становится узел _block_. А уже в него
помещаются узлы:
- узел _send_ с вызовом метода
- аргументы блока и
- тело блока.

Структура AST-дерева для вызова с блоком без аргументов:

<img src="/assets/images/2020-07-09-rubocop-ast-trees/nodes-basic-block.svg" />

Ruby выражение:

```ruby
title do
end
```

S-выражение для дерева:

```common-lisp
(block
  (send nil :title)
  (args) nil)
```

#### Если блок принимает один аргумент

Если в блоке только один аргумент, то он представляется не узлом _arg_,
а _procarg0_.

Ruby выражение:

```ruby
title do |t|
end
```

S-выражение для дерева:

```common-lisp
(block
  (send nil :title)
  (args
    (procarg0
      (arg :t))) nil)
```

Разработчикам пришлось ввести новый узел _procarg0_ по вполне
определенной причине. Это сделано потому, что в Ruby аргументы блока
трактуются по разному в зависимости от их количества - один или
несколько.

Если в блоке один аргумент и передали аргументом массив - аргументу
присваивается этот массив. Если в блоке несколько аргументов, то
происходит деструкция массива и аргументам блока присвоятся значения
элементов этого массива. Прикольно, не правда ли.

И полагаться просто на количество аргументов нельзя, так как возможен
вариант неявного _rest_-аргумента. Если к единственному аргументу
добавить символ ",", например `|t,|`, то получиться, что аргумент один,
но все равно переданное значение-массив будет деструктурировано.
Проиллюстрируем это примерами.

Пример №1. В блоке один аргумент - ему присваивается значение-массив:

```ruby
block = proc { |a| puts "=> #{a}" }
block.call([1, 2])
# => [1, 2]
```

Пример №2. Два аргумента - аргументам присваиваются значения элементов
массива - 1 и 2:

```ruby
block = proc { |a, b| puts "=> #{a} | #{b}" }
block.call([1, 2])
# => 1 | 2
```

Пример №3. Один явный аргумент + неявный _rest_-аргумент. Явному первому
аргументу присвоится значение первого элемента массива - 1:

```ruby
block = proc { |a,| puts "=> #{a}" }
block.call([1, 2])
# => 1
```

Чтобы различить первый пример и последний как раз и нужен специальный
дополнительный узел _procarg0_.

#### Если блок принимает несколько аргументов

Ruby выражение:

```ruby
title do |t, f|
end
```

S-выражение для дерева:

```common-lisp
(block
  (send nil :title)
  (args
    (arg :t)
    (arg :f)) nil)
```

#### Если блок не пустой

Ruby выражение:

```ruby
title do
  foo
end
```

S-выражение для дерева:

```common-lisp
(block
  (send nil :title)
  (args)
  (send nil :foo))
```

#### Если несколько выражений в блоке

Если в блоке несколько выражений, то они оборачиваются в узел _begin_.

Ruby выражение:

```ruby
title do
  foo
  "Post #1"
end
```

S-выражение для дерева:

```common-lisp
(block
  (send nil :title)
  (args)
  (begin
    (send nil :foo)
    (str "Post #1")))
```

### Константы

Константа представляется одним родительским узлом _const_ и двумя
дочерними:
- пространство имен
- имя константы

Структура AST-дерева для константы:

<img src="/assets/images/2020-07-09-rubocop-ast-trees/nodes-basic-const.svg" />

#### Константа без пространства имен

Если у константы нет явного пространства имен, тогда используется _nil_.

Ruby выражение:

```ruby
A
```

S-выражение для дерева:

```common-lisp
(const nil :A)
```

AST-дерево:

<img src="/assets/images/2020-07-09-rubocop-ast-trees/nodes-basic-const-wo-scope.svg" />

#### Константа с пространством имен

Ruby выражение:

```ruby
A::B
```

S-выражение для дерева:

```common-lisp
(const
  (const nil :A) :B)
```

AST-дерево:

<img src="/assets/images/2020-07-09-rubocop-ast-trees/nodes-basic-const-w-scope.svg" />

#### Длинная цепочка имен

Ruby выражение:

```ruby
A::B::C
```

S-выражение для дерева:

```common-lisp
(const
  (const
    (const nil :A) :B) :C)
```

#### Константа с приставкой ::

Ruby выражение:

```ruby
::A
```

S-выражение для дерева:

```common-lisp
(const
  (cbase) :A)
```

### Декларация класса

Класс представляется узлом _class_, со следующими дочерними узлами:
- имя класса
- родительский класс и
- тело класса.

Структура AST-дерева для класса:

<img src="/assets/images/2020-07-09-rubocop-ast-trees/nodes-basic-class.svg" />

Если родительский класс не указан то используют _nil_. Аналогично, если
тело класса пустое - используется тоже _nil_.

Ruby выражение:

```ruby
class A
end
```

S-выражение для дерева:

```common-lisp
(class
  (const nil :A) nil nil)
```

AST-дерево:

<img src="/assets/images/2020-07-09-rubocop-ast-trees/nodes-basic-class-empty.svg" />

#### Наследует базовый класс

Ruby выражение:

```ruby
class A < B
end
```

S-выражение для дерева:

```common-lisp
(class
  (const nil :A)
  (const nil :B) nil)
```

#### Одно выражение в теле класса

Ruby выражение:

```ruby
class A
  def initialize
  end
end
```

S-выражение для дерева:

```common-lisp
(class
  (const nil :A) nil
  (def :initialize
    (args) nil))
```

#### Несколько выражений в теле класса

Если в классе только одно выражение - оно представляет тело класса. Если
выражений больше одного - они оборачиваются в узел _begin_.

Ruby выражение:

```ruby
class A
  def initialize
  end

  def empty?
    true
  end
end
```

S-выражение для дерева:

```common-lisp
(class
  (const nil :A) nil
  (begin
    (def :initialize
      (args) nil)
    (def :empty?
      (args)
      (true))))
```

### Как сгенерировать AST-дерево

Давайте отвлечемся от примеров и рассмотрим способы, как же получить
AST-дерево для какого-то конкретного Ruby-кода.

Есть несколько вариантов. Один из них - _shell_-команда `ruby-parse`,
которая идет в составе _gem_'а _parser_.

Пример вызова этой команды для простого арифметического выражения:

```shell
$ ruby-parse -e "1 + 2"
(send
  (int 1) :+
  (int 2))
```

Второй вариант - вызвать парсер напрямую из Ruby-кода (пример из
[документации](https://docs.rubocop.org/rubocop/0.85/development.html#inspecting-the-ast-representation)):

```ruby
require 'rubocop'

code = '!something.empty?'
source = RuboCop::ProcessedSource.new(code, RUBY_VERSION.to_f)
node = source.ast
```

```common-lisp
s(:send,
  s(:send,
    s(:send, nil, :something), :empty?), :!)
```

### PS

Мы рассмотрели лишь несколько узлов AST-дерева и опустили подробности.
Но теперь мы можем сами генерировать AST-деревья и изучать их глубже.

Полный список типов узлов с примерами можно найти в
[документации](https://github.com/whitequark/parser/blob/master/doc/AST_FORMAT.md)
_gem_'а _parser_. Также очень полезна секция
[_Documentation_](https://github.com/whitequark/parser#documentation) в
его Readme файле.

### Ссылки

- <https://docs.rubocop.org/rubocop/0.85/development.html>
- <https://github.com/whitequark/parser>
- <https://github.com/whitequark/parser/blob/master/doc/AST_FORMAT.md>


[jekyll-gh]: https://github.com/mojombo/jekyll
[jekyll]:    http://jekyllrb.com
